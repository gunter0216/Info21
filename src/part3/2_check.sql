-- 1) Написать функцию, возвращающую таблицу TransferredPoints в более человекочитаемом виде
-- Ник пира 1, ник пира 2, количество переданных пир поинтов. 
-- Количество отрицательное, если пир 2 получил от пира 1 больше поинтов.
select *
from TransferredPoints();
--
-- 2) Написать функцию, которая возвращает таблицу вида: 
-- ник пользователя, название проверенного задания, кол-во полученного XP
-- В таблицу включать только задания, успешно прошедшие проверку (определять по таблице Checks).
-- Одна задача может быть успешно выполнена несколько раз. 
-- В таком случае в таблицу включать все успешные проверки.
select *
from CheckedPeersWithXP();
--
-- 3) Написать функцию, определяющую пиров, которые не выходили из кампуса в течение всего дня
-- Параметры функции: день, например 12.05.2022.
-- Функция возвращает только список пиров.
select *
from PeersInCampus('2022-09-04');
--
-- 4) Найти процент успешных и неуспешных проверок за всё время
-- Формат вывода: процент успешных, процент неуспешных
CALL CheckSuccessRatio('task4');
FETCH ALL
FROM "task4";
CLOSE "task4";
--
-- 5) Посчитать изменение в количестве пир поинтов каждого пира по таблице TransferredPoints
-- Результат вывести отсортированным по изменению числа поинтов. 
-- Формат вывода: ник пира, изменение в количество пир поинтов
CALL PointsChange('task5');
FETCH ALL
FROM "task5";
CLOSE "task5";
--
-- 6) Посчитать изменение в количестве пир поинтов каждого пира по таблице, возвращаемой первой функцией из Part 3
-- Результат вывести отсортированным по изменению числа поинтов. 
-- Формат вывода: ник пира, изменение в количество пир поинтов
CALL PointsChange_v2('task6');
FETCH ALL
FROM "task6";
CLOSE "task6";
--
-- 7) Определить самое часто проверяемое задание за каждый день
-- При одинаковом количестве проверок каких-то заданий в определенный день, вывести их все. 
-- Формат вывода: день, название задания
CALL MostFrequentTaskDaily('task7');
FETCH ALL
FROM "task7";
CLOSE "task7";
--
-- 8) Определить длительность последней P2P проверки
-- Под длительностью подразумевается разница между временем, 
-- указанным в записи со статусом "начало", и временем, указанным в записи со статусом "успех" или "неуспех". 
-- Формат вывода: длительность проверки
CALL DurationLatestP2PCheck();
--
-- 9) Найти всех пиров, выполнивших весь заданный блок задач и дату завершения последнего задания
-- Параметры процедуры: название блока, например "CPP". 
-- Результат вывести отсортированным по дате завершения. 
-- Формат вывода: ник пира, дата завершения блока (т.е. последнего выполненного задания из этого блока)
CALL CompleteBlock('task9', 'A');
FETCH ALL
FROM "task9";
CLOSE "task9";
--
-- 10) Определить, к какому пиру стоит идти на проверку каждому обучающемуся
-- Определять нужно исходя из рекомендаций друзей пира, т.е. нужно найти пира, проверяться у которого рекомендует наибольшее число друзей. 
-- Формат вывода: ник пира, ник найденного проверяющего
CALL FindPeerForCheck('task10');
FETCH ALL
FROM "task10";
CLOSE "task10";
--
-- 11) Определить процент пиров, которые:
--
-- Приступили к блоку 1
-- Приступили к блоку 2
-- Приступили к обоим
-- Не приступили ни к одному
--
-- Параметры процедуры: название блока 1, например CPP, название блока 2, например A.
-- Формат вывода: процент приступивших к первому блоку, процент приступивших ко второму блоку, 
-- процент приступивших к обоим, процент не приступивших ни к одному
CALL PeersByGroups('task11');
fetch all
FROM "task11";
CLOSE "task11";
--
-- 12) Определить N пиров с наибольшим числом друзей
-- Параметры процедуры: количество пиров N. 
-- Результат вывести отсортированным по кол-ву друзей. 
-- Формат вывода: ник пира, количество друзей
CALL PeersWithGreatestNumberFriends('task12', 2);
FETCH ALL
FROM "task12";
CLOSE "task12";
--
-- 13) Определить процент пиров, которые когда-либо успешно проходили проверку в свой день рождения
-- Также определите процент пиров, которые хоть раз проваливали проверку в свой день рождения.
-- Формат вывода: процент успехов в день рождения, процент неуспехов в день рождения
CALL PeersWithBDayCheck('data');
fetch all
FROM "data";
--
-- 14) Определить кол-во XP, полученное в сумме каждым пиром
-- Если одна задача выполнена несколько раз, полученное за нее кол-во XP равно максимальному за эту задачу. 
-- Результат вывести отсортированным по кол-ву XP. 
-- Формат вывода: ник пира, количество XP
CALL TotalXP('task14');
FETCH ALL
FROM "task14";
CLOSE "task14";
--
-- 15) Определить всех пиров, которые сдали заданные задания 1 и 2, но не сдали задание 3
-- Параметры процедуры: названия заданий 1, 2 и 3. 
-- Формат вывода: список пиров
CALL GivenAndNotGivenTasks(
    'task15',
    's21_SimpleBashUtils',
    's21_decimal',
    'A_Parallels'
);
FETCH ALL
FROM "task15";
CLOSE "task15";
--
select c.id,
    c.peer,
    c.task,
    p.state AS p2p,
    v.state AS Verter
from checks c
    JOIN p2p p ON p.check_ = c.id
    left join verter v ON v.check_ = c.id
WHERE (
        v.state != 'Start'
        OR v.state IS NULL
    )
    AND p.state != 'Start';
--
-- 16) Используя рекурсивное обобщенное табличное выражение, 
-- для каждой задачи вывести кол-во предшествующих ей задач
-- То есть сколько задач нужно выполнить, исходя из условий входа, 
-- чтобы получить доступ к текущей. 
-- Формат вывода: название задачи, количество предшествующих
CALL CountOfPreviousTasks('task16');
fetch all
FROM "task16";
CLOSE "task16";
--
-- 17) Найти "удачные" для проверок дни. День считается "удачным", 
-- если в нем есть хотя бы N идущих подряд успешных проверки
-- Параметры процедуры: количество идущих подряд успешных проверок N. 
-- Временем проверки считать время начала P2P этапа. 
-- Под идущими подряд успешными проверками подразумеваются успешные проверки, между которыми нет неуспешных. 
-- При этом кол-во опыта за каждую из этих проверок должно быть не меньше 80% от максимального. 
-- Формат вывода: список дней
CALL FindLuckyDaysForChecks('task17', 3);
FETCH ALL
FROM "task17";
CLOSE "task17";
--
-- 18) Определить пира с наибольшим числом выполненных заданий
-- Формат вывода: ник пира, число выполненных заданий
CALL GetPeerWithMaxTasks('task18');
fetch all
FROM "task18";
CLOSE "task18";
--
-- 19) Определить пира с наибольшим количеством XP
-- Формат вывода: ник пира, количество XP
CALL GetPeerWithMaxXp('task19');
fetch all
FROM "task19";
CLOSE "task19";
--
-- 20) Определить пира, который провел сегодня в кампусе больше всего времени
-- Формат вывода: ник пира
CALL GetPeerMaxTimeSpent('task20');
fetch all
FROM "task20";
CLOSE "task20";
--
-- 21) Определить пиров, приходивших раньше заданного времени не менее N раз за всё время
-- Параметры процедуры: время, количество раз N. 
-- Формат вывода: список пиров
CALL GetPeerMaxTimeSpent('data', '11:20:00', 0);
FETCH ALL
FROM "data";
CLOSE "data";
CALL GetPeerMaxTimeSpent('data', '11:20:00', 1);
FETCH ALL
FROM "data";
CLOSE "data";
--
-- 22) Определить пиров, выходивших за последние N дней из кампуса больше M раз
-- Параметры процедуры: количество дней N, количество раз M.
-- Формат вывода: список пиров
CALL foo22('data', 1, 0);
fetch all
FROM "data";
CLOSE "data";
--
-- 23) Определить пира, который пришел сегодня последним
-- Формат вывода: ник пира
CALL PeerLastOut('data');
fetch all
FROM "data";
CLOSE "data";
--
-- 24) Определить пиров, которые выходили вчера из кампуса больше чем на N минут
-- Параметры процедуры: количество минут N.
-- Формат вывода: список пиров
CALL PeersLeftNMinutes('data', 30);
fetch all
FROM "data";
CLOSE "data";
--
-- 25) Определить для каждого месяца процент ранних входов
-- Для каждого месяца посчитать, сколько раз люди, родившиеся в этот месяц, 
-- приходили в кампус за всё время (будем называть это общим числом входов).
-- Для каждого месяца посчитать, сколько раз люди, родившиеся в этот месяц, 
-- приходили в кампус раньше 12:00 за всё время (будем называть это числом ранних входов).
-- Для каждого месяца посчитать процент ранних входов в кампус относительно общего числа входов.
-- Формат вывода: месяц, процент ранних входов
CALL foo25('data');
fetch all
FROM "data";
CLOSE "data";